0         ld  x3, x2(0)            // 00 load x0 <- mem x2   0                  alu_op = 000  x0 = 1 mem 0   0
4         ld  x1, x2(4)            // 01 load x1 <- mem x2   4                  alu_op = 000  x1 = 2 mem 0   4
8         add x2, x3, x1           // 02 add x2 <- x0   x1                       alu_op = 000  x2 = 3
12        st  x2, x1(0)            // 03 store mem x1   0 <- x2                 alu_op = 000  mem 4   0 = 3
16        sub x2, x3, x1           // 04 sub x2 <- x0 - x1                       alu_op = 001  x2 = 1111_1111_1111_1111__1111_1111_1111_1111  -1
20        inv x2, x3               // 05 invert x2 <- !x0                        alu_op = 100  x2 = 1111111111111110
24        lsl x2, x3, x1           // 06 logical shift left x2 <- x0<<x1         alu_op = 011  x2 = 0000000000000100
28        lsr x2, x3, x1           // 07 logical shift xight x2 <- x0>>x1        alu_op = 100  x2 = 0000000000000000
32        and x2, x3, x1           // 08 and x2<- x0 and x1                      alu_op = 101  x2 = 0000000000000000
36        or  x2, x3, x1           // 09 or x2<- x0 or x1                        alu_op = 110  x2 = 0000000000000011
40        slt x2, x3, x1           // 0a slt x2 <- 1 if x0 < x1                  alu_op = 111  x2 = 0000000000000001
44        add x3, x3, x3           // 0b add x0 <- x0   x0                       alu_op = 000  x0 = 0000000000000010
48        beq x3, x2, 4            // 0c beq branch to jump if x0==x2, pcnew= pc 4 offset<<2 = 28 => offset = 1  will not branch {jump 56}
52        bne x3, x2, 0            // 0d bne branch to jump if x0!=x2, pcnew= pc 4 offset<<2 = 28 => offset = 0  will branch {jump 56}
56        jmp 0                    // 0e j jump to the beginning address {jump 60}
