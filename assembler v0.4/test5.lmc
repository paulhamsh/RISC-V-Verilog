0          000000000000_00010_000_00011_0000011 // 00 load x0 <- mem x2   0                  alu_op = 000  x0 = 1 mem 0   0
4          000000000100_00010_000_00001_0000011 // 01 load x1 <- mem x2   4                  alu_op = 000  x1 = 2 mem 0   4
8        000000_0_00001_00011_000_00010_0001011 // 02 add x2 <- x0   x1                       alu_op = 000  x2 = 3
12        0000000_00010_00001_000_00000_0000111 // 03 store mem x1   0 <- x2                 alu_op = 000  mem 4   0 = 3
16       000000_0_00001_00011_000_00010_0001111 // 04 sub x2 <- x0 - x1                       alu_op = 001  x2 = 1111_1111_1111_1111__1111_1111_1111_1111  -1
20        000000_000000_00011_000_00010_0010011 // 05 invert x2 <- !x0                        alu_op = 100  x2 = 1111111111111110
24       000000_0_00001_00011_000_00010_0010111 // 06 logical shift left x2 <- x0<<x1         alu_op = 011  x2 = 0000000000000100
28       000000_0_00001_00011_000_00010_0011011 // 07 logical shift xight x2 <- x0>>x1        alu_op = 100  x2 = 0000000000000000
32       000000_0_00001_00011_000_00010_0011111 // 08 and x2<- x0 and x1                      alu_op = 101  x2 = 0000000000000000
36       000000_0_00001_00011_000_00010_0100011 // 09 or x2<- x0 or x1                        alu_op = 110  x2 = 0000000000000011
40       000000_0_00001_00011_000_00010_0100111 // 0a slt x2 <- 1 if x0 < x1                  alu_op = 111  x2 = 0000000000000001
44       000000_0_00011_00011_000_00011_0001011 // 0b add x0 <- x0   x0                       alu_op = 000  x0 = 0000000000000010
48      0_000000_00010_00011_000_0010_0_0101111 // 0c beq branch to jump if x0==x2, pcnew= pc 4 offset<<2 = 28 => offset = 1  will not branch 
52      0_000000_00010_00011_000_0000_0_0110011 // 0d bne branch to jump if x0!=x2, pcnew= pc 4 offset<<2 = 28 => offset = 0  will branch 
56        0_0000000000_0_00000000_00000_0110111 // 0e j jump to the beginning address
