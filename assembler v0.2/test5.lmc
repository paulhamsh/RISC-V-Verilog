0       00000000_00000000_0000_010_000_000000 // 00 load r0 <- mem r2   0                  alu_op = 000  r0 = 1 mem 0   0
4       00000000_00000000_0000_010_001_000100 // 01 load r1 <- mem r2   4                  alu_op = 000  r1 = 2 mem 0   4
8       00000000_00000000_0010_000_001_010_000 // 02 add r2 <- r0   r1                       alu_op = 000  r2 = 3
12      00000000_00000000_0001_001_010_000000 // 03 store mem r1   0 <- r2                 alu_op = 000  mem 4   0 = 3
16      00000000_00000000_0011_000_001_010_000 // 04 sub r2 <- r0 - r1                       alu_op = 001  r2 = 1111_1111_1111_1111__1111_1111_1111_1111  -1
20      00000000_00000000_0100_000_000_010_000 // 05 invert r2 <- !r0                        alu_op = 100  r2 = 1111111111111110
24      00000000_00000000_0101_000_001_010_000 // 06 logical shift left r2 <- r0<<r1         alu_op = 011  r2 = 0000000000000100
28      00000000_00000000_0110_000_001_010_000 // 07 logical shift right r2 <- r0>>r1        alu_op = 100  r2 = 0000000000000000
32      00000000_00000000_0111_000_001_010_000 // 08 and r2<- r0 and r1                      alu_op = 101  r2 = 0000000000000000
36      00000000_00000000_1000_000_001_010_000 // 09 or r2<- r0 or r1                        alu_op = 110  r2 = 0000000000000011
40      00000000_00000000_1001_000_001_010_000 // 0a slt r2 <- 1 if r0 < r1                  alu_op = 111  r2 = 0000000000000001
44      00000000_00000000_0010_000_000_000_000 // 0b add r0 <- r0   r0                       alu_op = 000  r0 = 0000000000000010
48      00000000_00000000_1011_000_010_000001 // 0c beq branch to jump if r0==r2, pcnew= pc 2 offset<<1 = 28 => offset = 1  will not branch 
52      00000000_00000000_1100_000_010_000000 // 0d bne branch to jump if r0!=r2, pcnew= pc 2 offset<<1 = 28 => offset = 0  will branch 
56      00000000_00000000_1101_000000000000 // 0e j jump to the beginning address
