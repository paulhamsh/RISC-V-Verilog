// This can be single stepped in the testbench
// 00000000_00000000_0000_010_000_000000  // 00 00 load R0 <- Mem(R2 + 0)                  ALU_op = 000  R0 = 1 Mem[0 + 0] 
// 00000000_00000000_0000_010_001_000100  // 04 04 load R1 <- Mem(R2 + 4)                  ALU_op = 000  R1 = 2 Mem[0 + 4]
// 00000000_00000000_0010_000_001_010_000 // 08 08 Add R2 <- R0 + R1                       ALU_op = 000  R2 = 3
// 00000000_00000000_0001_001_010_000_000 // 0c 12 Store Mem(R1 + 0) <- R2                 ALU_op = 000  Mem[4 + 0] = 3
// 00000000_00000000_0011_000_001_010_000 // 10 16 sub R2 <- R0 - R1                       ALU_op = 001  R2 = 1111_1111_1111_1111__1111_1111_1111_1111 (-1)
// 00000000_00000000_0100_000_001_010_000 // 14 20 invert R2 <- !R0                        ALU_op = 100  R2 = 1111111111111110
// 00000000_00000000_0101_000_001_010_000 // 18 24 logical shift left R2 <- R0<<R1         ALU_op = 011  R2 = 0000000000000100
// 00000000_00000000_0110_000_001_010_000 // 1c 28 logical shift right R2 <- R0>>R1        ALU_op = 100  R2 = 0000000000000000
// 00000000_00000000_0111_000_001_010_000 // 20 32 AND R2<- R0 AND R1                      ALU_op = 101  R2 = 0000000000000000
// 00000000_00000000_1000_000_001_010_000 // 24 36 OR R2<- R0 OR R1                        ALU_op = 110  R2 = 0000000000000011
// 00000000_00000000_1001_000_001_010_000 // 28 40 SLT R2 <- 1 if R0 < R1                  ALU_op = 111  R2 = 0000000000000001
// 00000000_00000000_0010_000_000_000_000 // 2c 44 Add R0 <- R0 + R0                       ALU_op = 000  R0 = 0000000000000010
// 00000000_00000000_1011_000_010_000010  // 30 48 BEQ branch to jump if R0==R2            will not branch
// 00000000_00000000_1100_000_010_000001  // 34 52 BNE branch to jump if R0!=R2            will branch to 3c / 17
// 00000000_00000000_1101_000000000000    // 38 56 J jump to 0
// 00000000_00000000_1101_000000000100    // 3c 60 J jump to 10 / 16 


// [start:0]
// 0       000000_000_000_00_010_00000_000_000_0000
// 4       000100_000_000_00_010_00000_001_000_0000
// 8       000000_000_001_00_000_00000_010_000_0010
// 12      000000_000_010_00_001_00000_000_000_0001
// 16      000000_000_001_00_000_00000_010_000_0011
// 20      000000_000_000_00_000_00000_010_000_0100
// 24      000000_000_001_00_000_00000_010_000_0101
// 28      000000_000_001_00_000_00000_010_000_0110
// 32      000000_000_001_00_000_00000_010_000_0111
// 36      000000_000_001_00_000_00000_010_000_1000
// 40      000000_000_001_00_000_00000_010_000_1001
// 44      000000_000_000_00_000_00000_000_000_0010
// 48      000000_000_010_00_000_00000_000_000_1011
// 52      000000_000_010_00_000_00000_000_000_1100
// 56      000000000000_00_000_00000_000_000_1101
// 60      000000000010_00_000_00000_000_000_1101

start:
	ld r0, r2(0)
	ld r1, r2(4)
	add r2, r0, r1
	st r2, r1(0)
	sub r2, r0, r1
	inv r2, r0
	lsl r2, r0, r1
	lsr r2, r0, r1
	and r2, r0, r1
	or r2, r0, r1
	slt r2, r0, r1
	add r0, r0, r0
	beq r0, r2, 8
	bne r0, r2, 4
	jmp start
	jmp 16