        000000_0_00000_00010_000_00011_0000011 // 00 load x0 <- mem x2   0                  alu_op = 000  x0 = 1 mem 0   0
        000100_0_00000_00010_000_00001_0000011 // 01 load x1 <- mem x2   4                  alu_op = 000  x1 = 2 mem 0   4
        000000_0_00001_00011_000_00010_0001011 // 02 add x2 <- x0   x1                       alu_op = 000  x2 = 3
        000000_0_00010_00001_000_00000_0000111 // 03 store mem x1   0 <- x2                 alu_op = 000  mem 4   0 = 3
        000000_0_00001_00011_000_00010_0001111 // 04 sub x2 <- x0 - x1                       alu_op = 001  x2 = 1111_1111_1111_1111__1111_1111_1111_1111  -1
         000000_000000_00011_000_00010_0010011 // 05 invert x2 <- !x0                        alu_op = 100  x2 = 1111111111111110
        000000_0_00001_00011_000_00010_0010111 // 06 logical shift left x2 <- x0<<x1         alu_op = 011  x2 = 0000000000000100
        000000_0_00001_00011_000_00010_0011011 // 07 logical shift xight x2 <- x0>>x1        alu_op = 100  x2 = 0000000000000000
        000000_0_00001_00011_000_00010_0011111 // 08 and x2<- x0 and x1                      alu_op = 101  x2 = 0000000000000000
        000000_0_00001_00011_000_00010_0100011 // 09 or x2<- x0 or x1                        alu_op = 110  x2 = 0000000000000011
        000000_0_00001_00011_000_00010_0100111 // 0a slt x2 <- 1 if x0 < x1                  alu_op = 111  x2 = 0000000000000001
        000000_0_00011_00011_000_00011_0001011 // 0b add x0 <- x0   x0                       alu_op = 000  x0 = 0000000000000010
        000001_0_00010_00011_000_00000_0101111 // 0c beq branch to jump if x0==x2, pcnew= pc 2 offset<<1 = 28 => offset = 1  will not branch 
        000000_0_00010_00011_000_00000_0110011 // 0d bne branch to jump if x0!=x2, pcnew= pc 2 offset<<1 = 28 => offset = 0  will branch 
          000000000000_00000_000_00000_0110111 // 0e j jump to the beginning address
