// This can be single stepped in the testbench
00000000_00000000_0000_010_000_000000  // 00 load R0 <- Mem(R2 + 0)                  ALU_op = 000  R0 = 1 Mem[0 + 0] 
00000000_00000000_0000_010_001_000100  // 01 load R1 <- Mem(R2 + 4)                  ALU_op = 000  R1 = 2 Mem[0 + 4]
00000000_00000000_0010_000_001_010_000 // 02 Add R2 <- R0 + R1                       ALU_op = 000  R2 = 3
00000000_00000000_0001_001_010_000_000 // 03 Store Mem(R1 + 0) <- R2                 ALU_op = 000  Mem[4 + 0] = 3
00000000_00000000_0011_000_001_010_000 // 04 sub R2 <- R0 - R1                       ALU_op = 001  R2 = 1111_1111_1111_1111__1111_1111_1111_1111 (-1)
00000000_00000000_0100_000_001_010_000 // 05 invert R2 <- !R0                        ALU_op = 100  R2 = 1111111111111110
00000000_00000000_0101_000_001_010_000 // 06 logical shift left R2 <- R0<<R1         ALU_op = 011  R2 = 0000000000000100
00000000_00000000_0110_000_001_010_000 // 07 logical shift right R2 <- R0>>R1        ALU_op = 100  R2 = 0000000000000000
00000000_00000000_0111_000_001_010_000 // 08 AND R2<- R0 AND R1                      ALU_op = 101  R2 = 0000000000000000
00000000_00000000_1000_000_001_010_000 // 09 OR R2<- R0 OR R1                        ALU_op = 110  R2 = 0000000000000011
00000000_00000000_1001_000_001_010_000 // 0a SLT R2 <- 1 if R0 < R1                  ALU_op = 111  R2 = 0000000000000001
00000000_00000000_0010_000_000_000_000 // 0b Add R0 <- R0 + R0                       ALU_op = 000  R0 = 0000000000000010
00000000_00000000_1011_000_010_000001  // 0c BEQ branch to jump if R0==R2, PCnew= PC+2+offset<<1 = 28 => offset = 1  will not branch
00000000_00000000_1100_000_010_000000  // 0d BNE branch to jump if R0!=R2, PCnew= PC+2+offset<<1 = 28 => offset = 0  will branch
00000000_00000000_1101_000000000000    // 0e J jump to the beginning address