       // this can be single stepped in the testbench
       //  start:0
       // 0       000000_0_00000_00010_000_00011_0000000   // 00 00 load x3 <- mem x2   0                  x3 = 1 mem 0   0
       // 4       000100_0_00000_00010_000_00001_0000000   // 04 04 load x1 <- mem x2   4                  x1 = 2 mem 0   4
       // 8       000000_0_00001_00011_000_00010_0000010   // 08 08 add x2 <- x3   x1                       x2 = 3
       // 12      000000_0_00010_00001_000_00000_0000001   // 0c 12 store mem x1   0 <- x2                 mem 4   0 = 3
       // 16      000000_0_00001_00011_000_00010_0000011   // 10 16 sub x2 <- x3 - x1                       x2 = 1111_1111_1111_1111__1111_1111_1111_1111  -1
       // 20       000000_000000_00011_000_00010_0000100   // 14 20 invert x2 <- !x3                        x2 = 1111111111111110
       // 24      000000_0_00001_00011_000_00010_0000101   // 18 24 logical shift left x2 <- x3 << x1       x2 = 0000000000000100
       // 28      000000_0_00001_00011_000_00010_0000110   // 1c 28 logical shift right x2 <- x3 >> x1      x2 = 0000000000000000
       // 32      000000_0_00001_00011_000_00010_0000111   // 20 32 and x2<- x3 and x1                      x2 = 0000000000000000
       // 36      000000_0_00001_00011_000_00010_0001000   // 24 36 or x2<- x3 or x1                        x2 = 0000000000000011
       // 40      000000_0_00001_00011_000_00010_0001001   // 28 40 slt x2 <- 1 if x3 < x1                  x2 = 0000000000000001
       // 44      000000_0_00000_00011_000_00000_0000010   // 2c 44 add x3 <- x3   x3                       x3 = 0000000000000010
       // 48      000010_0_00010_00000_000_00000_0001011   // 30 48 beq branch to jump if x3==x2            will not branch
       // 52      000001_0_00010_00000_000_00000_0001100   // 34 52 bne branch to jump if x3!=x2            will branch to 3c / 17
       // 56        000000000000_00000_000_00000_0001101   // 38 56 j jump to 0
       // 60        000000000100_00000_000_00000_0001101   // 3c 60 j jump to 10 / 16
// [start:0]
0          000000000000_00010_000_00011_0000000 
4          000000000100_00010_000_00001_0000000 
8        000000_0_00001_00011_000_00010_0001000 
12        0000000_00010_00001_000_00000_0000100 
16       000000_0_00001_00011_000_00010_0001100 
20        000000_000000_00011_000_00010_0010000 
24       000000_0_00001_00011_000_00010_0010100 
28       000000_0_00001_00011_000_00010_0011000 
32       000000_0_00001_00011_000_00010_0011100 
36       000000_0_00001_00011_000_00010_0100000 
40       000000_0_00001_00011_000_00010_0100100 
44       000000_0_00011_00011_000_00011_0001000 
48      0_000000_00010_00011_000_0110_0_0101100 
52      0_000000_00010_00011_000_0100_0_0110000 
56        1_1111100100_1_11111111_00000_0110100 
60        1_1111101010_1_11111111_00000_0110100 
